#!/usr/bin/env python3
# -*- mode: python -*-

# TODO: add `ksys test`, which restarts, sends some example requests, and shows logs if failed
# TODO: Reconsider how .ksys should work.
#       + I'd prefer if `name`, `port`, `$(pwd)`, `domain` weren't in the files themselves, and were instead templated in.
#       + I'd prefer if the nginx conf had a filename that clearly identified it as nginx.  What about `%etc%nginx%sites-available%foo.example.com`?  Likewise systemd.
#       + I don't want to have SSL info inside `.ksys/`, but I also don't like that the nginx conf in that folder is different from the real conf.

if __name__ == '__main__':
    import subprocess, sys
    p = subprocess.run(['/usr/bin/which', 'flake8'], capture_output=True)
    if p.returncode != 0:
        print('note: flake8 not found, so not checking syntax')
    else:
        p = subprocess.run(['flake8', '--show-source', '--ignore=E501,E302,E251,E701,E226,E305,E225,E261,E231,E301,E306,E402,E704,E265,E201,E202,E303,E124,E241,E127,E266,E221,E126,E129,F811,E222,E401,E702,E203,E116,E228,W504,W293,B007,W391,F841,F401', __file__])
        if p.returncode != 0: sys.exit(1)


import sys, subprocess, os, random, re, time
from pathlib import Path

os.environ['TZ'] = '/usr/share/zoneinfo/America/Detroit'

def get_unit_name() -> str:
    # TODO: look in parent dirs for `.ksys/`
    path = Path().absolute()
    if path.parts[:2] != ('/', 'srv'):
        raise Exception(f"Not in /srv/ : {path}")
    if len(path.parts) < 3:
        raise Exception("Cannot run directly in /srv/")
    project_name = path.parts[2]
    unit_name = f"kpa-{project_name}"
    print(f"Using unit: {unit_name}")
    return unit_name

def log(args):
    unit_name = args.unit or get_unit_name()
    if args and args.all:
        cmd = ["sudo", "journalctl", "-u", unit_name, '--no-hostname']
    else:
        last_run_id = subprocess.check_output(['systemctl','show','--value','-p','InvocationID',unit_name]).decode().strip()
        cmd = ["sudo", "journalctl", f"_SYSTEMD_INVOCATION_ID={last_run_id}", '--no-hostname']
    print(cmd)
    subprocess.call(cmd)

def stat(args):
    unit_name = (args and args.unit) or get_unit_name()
    cmd = ["sudo", "systemctl", "status", "-n0", unit_name]
    print(cmd)
    subprocess.call(cmd)
    print()
    cmd = ["sudo", "journalctl", "-n20", "-u", unit_name, '--no-hostname']
    print(cmd)
    subprocess.call(cmd)

def restart(args):
    unit_name = args.unit or get_unit_name()
    cmd = ["sudo", "systemctl", "restart", unit_name]
    print(cmd)
    subprocess.call(cmd)
    time.sleep(2)
    subprocess.call(['sudo', 'systemctl', 'is-failed', unit_name])

systemd_service_template = '''\
[Unit]
Description={name}
After=network.target

[Service]
User=nobody
Group=nogroup
WorkingDirectory={dir}
ExecStart={exec}
# EXIT_STATUS = number (nonzero if error); EXIT_CODE = what happened; $SERVICE_RESULT = why died
ExecStopPost=/srv/telegram-error-if-nonzero-arg1.sh $EXIT_STATUS {name}-execstoppost $EXIT_CODE $SERVICE_RESULT
'''
systemd_daemon_template = systemd_service_template + '''\

[Install]
WantedBy=multi-user.target
'''
systemd_scheduled_template = systemd_service_template + '''\
Type=oneshot
Nice=10
'''
systemd_timer_template = '''\
[Unit]
Description={name}

[Timer]
OnCalendar=*-*-* 00,12:00:00
RandomizedDelaySec=3h
Persistent=true

[Install]
WantedBy=timers.target
'''
nginx_template = '''\
server {
  server_name {domain};
  listen 80;
  location / {
    include proxy_params;
    proxy_pass http://localhost:{port};
  }
}
'''
nginx_template = re.subn(r'(\s})', r'\1}', re.subn(r'({\s)', r'{\1', nginx_template)[0])[0]  # escape `{` and `}`

def init(args):
    '''Make ./.ksys/ and put config in it.'''
    ksys_path = Path('.ksys')
    ksys_path.mkdir(exist_ok=True)
    name = str(args.name) if args.name else get_unit_name()
    directory = str(Path().absolute())
    if args.timer:
        (ksys_path / f'{name}.service').write_text(systemd_scheduled_template.format(
            name=name,
            dir=directory,
            exec='{exec}',
        ))
        (ksys_path / f'{name}.timer').write_text(systemd_timer_template.format(name=name))
    elif args.nginx:
        port = 8000 + random.randrange(1000)
        (ksys_path / f'{name}.service').write_text(systemd_daemon_template.format(
            name=name,
            dir=directory,
            exec='{exec}' + f' --port={port}',
        ))
        domain = f'{name[4:]}.petervh.com' if name.startswith('kpa-') else f'{name}.petervh.com'
        (ksys_path / f'{domain}.conf').write_text(nginx_template.format(domain=domain, port=port))
    else:
        (ksys_path / f'{name}.service').write_text(systemd_scheduled_template.format(
            name=name,
            dir=directory,
            exec='{exec}',
        ))
    print(f'Now populate Exec= in .ksys/{name}.service and run `ksys install`')


def install(args):
    '''Copy config to /etc/'''
    ksys_path = Path('.ksys')
    if not ksys_path.is_dir(): raise Exception('No directory ./.ksys')
    for path in ksys_path.iterdir():
        if path.suffix == '.timer':
            dest_path = Path('/etc/systemd/system') / path.name
            subprocess.call(['sudo', 'cp', '-f', str(path), str(dest_path)])
            subprocess.call(['sudo', 'systemctl', 'enable', path.name])
        elif path.suffix == '.service':
            dest_path = Path('/etc/systemd/system') / path.name
            subprocess.call(['sudo', 'cp', '-f', str(path), str(dest_path)])
            if 'WantedBy' in path.read_text():
                subprocess.call(['sudo', 'systemctl', 'enable', path.name])
        elif path.suffix == '.conf':
            dest_path = Path('/etc/nginx/sites-available' / path.name)
            subprocess.call(['sudo', 'cp', '-f', str(path), str(dest_path)])
            subprocess.call(['sudo', 'ln', '-sf', str(dest_path), '/etc/nginx/sites-enabled'])
            subprocess.call(['sudo', 'nginx', '-t'])
            subprocess.call(['sudo', 'systemctl', 'restart', 'nginx'])
            print('Maybe now run `certbot`')
        subprocess.call(['sudo', 'systemctl', 'daemon-reload'])

def venv(args):
    '''Make ./venv/ and append "venv" to .gitignore'''
    subprocess.call(['python3', '-m', 'venv', 'venv'])
    req_paths = [Path(p) for p in args.requirements_files] or [Path('requirements.txt')]
    for req_path in req_paths:
        subprocess.call(['./venv/bin/pip3', 'install', '-r', str(req_path)])
    if Path('.git').is_dir():
        gitignore_path = Path('.gitignore')
        if not gitignore_path.is_file():
            gitignore_path.write_text('venv\n')
        elif 'venv' not in gitignore_path.read_text():
            gitignore_path.write_text(gitignore_path.read_text().rstrip() + '\nvenv\n')



if __name__ == '__main__':
    import argparse
    parser = argparse.ArgumentParser()
    commands = parser.add_subparsers(dest='command')

    log_parser = commands.add_parser('log', aliases=['l'])
    log_parser.add_argument('-u', '--unit', type=str, default=None, help='What systemd unit')
    log_parser.add_argument('-a', '--all', action='store_true', help='Show all logs rather than only the latest run')
    log_parser.set_defaults(func=log)

    stat_parser = commands.add_parser('stat', aliases=['s'])
    stat_parser.add_argument('-u', '--unit', type=str, default=None, help='What systemd unit')
    stat_parser.set_defaults(func=stat)

    restart_parser = commands.add_parser('restart', aliases=['r'])
    restart_parser.add_argument('-u', '--unit', type=str, default=None, help='What systemd unit')
    restart_parser.set_defaults(func=restart)

    init_parser = commands.add_parser('init')
    init_parser.add_argument('--name', type=str, default=None, help='What name to use (defaults to kpa-{dirname})')
    init_parser.add_argument('--timer', action='store_true', help='Initialize as a timer rather than a daemon')
    init_parser.add_argument('--nginx', action='store_true', help='Initialize with nginx config')
    init_parser.set_defaults(func=init)

    install_parser = commands.add_parser('install')
    install_parser.set_defaults(func=install)

    install_parser = commands.add_parser('install')
    install_parser.set_defaults(func=install)

    venv_parser = commands.add_parser('venv')
    venv_parser.add_argument('requirements_files', type=str, nargs='*', help='requirements.txt files to install from')
    venv_parser.set_defaults(func=venv)

    args = parser.parse_args()
    if args.command is None:
        stat(None)
    else:
        args.func(args)
